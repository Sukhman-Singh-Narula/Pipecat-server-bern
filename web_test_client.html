<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 WebRTC AI Assistant - Test Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #2980b9;
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover:not(:disabled) {
            background: #c0392b;
        }
        
        button.success {
            background: #27ae60;
        }
        
        button.success:hover:not(:disabled) {
            background: #229954;
        }
        
        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .config-section h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #34495e;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .devices-list {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .device-item {
            background: white;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }
        
        .device-item.connected {
            border-left-color: #27ae60;
        }
        
        .device-item.disconnected {
            border-left-color: #e74c3c;
        }
        
        .audio-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .volume-control {
            flex: 1;
        }
        
        #microphoneButton.recording {
            background: #e74c3c;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ ESP32 WebRTC AI Assistant - Test Client</h1>
        
        <div id="connectionStatus" class="status disconnected">
            Status: Disconnected
        </div>
        
        <div class="config-section">
            <h3>Server Configuration</h3>
            <div class="form-group">
                <label for="serverUrl">Server URL:</label>
                <input type="text" id="serverUrl" value="http://localhost:8000" />
            </div>
            <div class="form-group">
                <label for="deviceId">Device ID:</label>
                <input type="text" id="deviceId" value="test_web_client_001" />
            </div>
            <div class="form-group">
                <label for="deviceName">Device Name:</label>
                <input type="text" id="deviceName" value="Web Test Client" />
            </div>
        </div>
        
        <div class="config-section">
            <h3>AI Configuration</h3>
            <div class="form-group">
                <label for="systemPrompt">System Prompt:</label>
                <textarea id="systemPrompt" placeholder="You are a helpful AI assistant...">You are a helpful AI assistant for testing purposes. Respond briefly and clearly to user queries. Your responses will be converted to audio.</textarea>
            </div>
            <div class="form-group">
                <label for="voiceId">Voice:</label>
                <select id="voiceId">
                    <option value="british_lady">British Lady</option>
                    <option value="american_male">American Male</option>
                    <option value="friendly_female">Friendly Female</option>
                </select>
            </div>
            <div class="form-group">
                <label for="language">Language:</label>
                <select id="language">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                </select>
            </div>
        </div>
        
        <div class="controls">
            <button id="connectButton" onclick="connectDevice()">Connect Device</button>
            <button id="disconnectButton" onclick="disconnectDevice()" disabled>Disconnect</button>
            <button id="updateConfigButton" onclick="updateConfig()" disabled>Update Config</button>
            <button id="testHealthButton" onclick="testHealth()">Test Health</button>
        </div>
        
        <div class="audio-controls">
            <button id="microphoneButton" onclick="toggleMicrophone()" disabled>üé§ Start Recording</button>
            <div class="volume-control">
                <label for="volumeSlider">Volume:</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="50" />
            </div>
        </div>
        
        <div class="devices-list">
            <h3>Connected Devices</h3>
            <div id="devicesList">Loading...</div>
            <button onclick="refreshDevices()">Refresh Devices</button>
        </div>
        
        <div class="config-section">
            <h3>Activity Log</h3>
            <div id="log" class="log">Waiting for activity...\n</div>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <script>
        class ESP32TestClient {
            constructor() {
                this.serverUrl = '';
                this.deviceId = '';
                this.connected = false;
                this.recording = false;
                this.mediaRecorder = null;
                this.audioChunks = [];
                
                this.updateConnectionStatus('disconnected', 'Disconnected');
                this.refreshDevices();
                
                // Auto-refresh devices every 10 seconds
                setInterval(() => this.refreshDevices(), 10000);
            }
            
            log(message, level = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('log');
                const levelEmoji = {
                    'info': '‚ÑπÔ∏è',
                    'success': '‚úÖ',
                    'error': '‚ùå',
                    'warning': '‚ö†Ô∏è'
                };
                
                logElement.textContent += `${timestamp} ${levelEmoji[level] || '‚ÑπÔ∏è'} ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.className = `status ${status}`;
                statusElement.textContent = `Status: ${message}`;
                
                // Update button states
                document.getElementById('connectButton').disabled = status === 'connected';
                document.getElementById('disconnectButton').disabled = status !== 'connected';
                document.getElementById('updateConfigButton').disabled = status !== 'connected';
                document.getElementById('microphoneButton').disabled = status !== 'connected';
            }
            
            async makeRequest(endpoint, method = 'GET', body = null) {
                const url = `${this.serverUrl}${endpoint}`;
                const options = {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                    },
                };
                
                if (body) {
                    options.body = JSON.stringify(body);
                }
                
                try {
                    const response = await fetch(url, options);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${data.detail || 'Unknown error'}`);
                    }
                    
                    return data;
                } catch (error) {
                    this.log(`Request failed: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async testHealth() {
                this.log('Testing server health...');
                
                try {
                    const health = await this.makeRequest('/health');
                    this.log(`Health check successful: ${health.status}`, 'success');
                    this.log(`Active devices: ${health.active_devices}`);
                    
                    const envCheck = health.environment_check;
                    for (const [service, available] of Object.entries(envCheck)) {
                        const status = available ? 'available' : 'missing';
                        this.log(`${service}: ${status}`, available ? 'success' : 'warning');
                    }
                    
                    return true;
                } catch (error) {
                    this.log(`Health check failed: ${error.message}`, 'error');
                    return false;
                }
            }
            
            async connectDevice() {
                this.serverUrl = document.getElementById('serverUrl').value;
                this.deviceId = document.getElementById('deviceId').value;
                const deviceName = document.getElementById('deviceName').value;
                
                if (!this.serverUrl || !this.deviceId) {
                    this.log('Please enter server URL and device ID', 'error');
                    return;
                }
                
                this.updateConnectionStatus('connecting', 'Connecting...');
                this.log(`Connecting to ${this.serverUrl} as ${this.deviceId}...`);
                
                try {
                    // Test server health first
                    await this.testHealth();
                    
                    // Register device
                    const registrationData = {
                        device_id: this.deviceId,
                        device_name: deviceName,
                        device_type: 'web_client',
                        capabilities: {
                            audio_input: true,
                            audio_output: true,
                            sample_rate: 16000,
                            channels: 1,
                            web_client: true
                        }
                    };
                    
                    await this.makeRequest('/api/device/register', 'POST', registrationData);
                    this.log('Device registered successfully', 'success');
                    
                    // Update configuration
                    await this.updateConfig();
                    
                    this.connected = true;
                    this.updateConnectionStatus('connected', 'Connected');
                    this.log('Device connected successfully', 'success');
                    
                    // Refresh devices list
                    this.refreshDevices();
                    
                } catch (error) {
                    this.updateConnectionStatus('disconnected', 'Connection Failed');
                    this.log(`Connection failed: ${error.message}`, 'error');
                }
            }
            
            async disconnectDevice() {
                if (!this.connected) return;
                
                this.log('Disconnecting device...');
                
                try {
                    await this.makeRequest(`/api/device/${this.deviceId}`, 'DELETE');
                    this.log('Device disconnected successfully', 'success');
                } catch (error) {
                    this.log(`Disconnect error: ${error.message}`, 'warning');
                }
                
                this.connected = false;
                this.updateConnectionStatus('disconnected', 'Disconnected');
                this.refreshDevices();
            }
            
            async updateConfig() {
                if (!this.connected) {
                    this.log('Device not connected', 'error');
                    return;
                }
                
                const config = {
                    system_prompt: document.getElementById('systemPrompt').value,
                    voice_id: document.getElementById('voiceId').value,
                    language: document.getElementById('language').value,
                    interrupt_enabled: true
                };
                
                try {
                    await this.makeRequest(`/api/device/${this.deviceId}/config`, 'POST', config);
                    this.log('Configuration updated successfully', 'success');
                } catch (error) {
                    this.log(`Config update failed: ${error.message}`, 'error');
                }
            }
            
            async refreshDevices() {
                try {
                    const devices = await this.makeRequest('/api/devices');
                    this.displayDevices(devices.devices);
                } catch (error) {
                    document.getElementById('devicesList').innerHTML = 
                        `<div class="device-item">Error loading devices: ${error.message}</div>`;
                }
            }
            
            displayDevices(devices) {
                const devicesList = document.getElementById('devicesList');
                
                if (devices.length === 0) {
                    devicesList.innerHTML = '<div class="device-item">No devices registered</div>';
                    return;
                }
                
                devicesList.innerHTML = devices.map(device => `
                    <div class="device-item ${device.connected ? 'connected' : 'disconnected'}">
                        <strong>${device.device_name || device.device_id}</strong>
                        <br>
                        ID: ${device.device_id}
                        <br>
                        Status: ${device.status} ${device.connected ? '(Connected)' : '(Disconnected)'}
                        <br>
                        <small>Registered: ${device.registered_at ? new Date(device.registered_at * 1000).toLocaleString() : 'Unknown'}</small>
                    </div>
                `).join('');
            }
            
            async toggleMicrophone() {
                if (!this.recording) {
                    await this.startRecording();
                } else {
                    this.stopRecording();
                }
            }
            
            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.audioChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        this.audioChunks.push(event.data);
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                        this.log(`Recorded audio: ${audioBlob.size} bytes`);
                        // In a real implementation, you would send this to the WebRTC connection
                        this.simulateAudioProcessing(audioBlob);
                    };
                    
                    this.mediaRecorder.start();
                    this.recording = true;
                    
                    const button = document.getElementById('microphoneButton');
                    button.textContent = 'üõë Stop Recording';
                    button.classList.add('recording');
                    
                    this.log('Recording started', 'success');
                    
                } catch (error) {
                    this.log(`Microphone access failed: ${error.message}`, 'error');
                }
            }
            
            stopRecording() {
                if (this.mediaRecorder && this.recording) {
                    this.mediaRecorder.stop();
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    this.recording = false;
                    
                    const button = document.getElementById('microphoneButton');
                    button.textContent = 'üé§ Start Recording';
                    button.classList.remove('recording');
                    
                    this.log('Recording stopped', 'success');
                }
            }
            
            simulateAudioProcessing(audioBlob) {
                // This simulates what would happen in a real WebRTC connection
                this.log('Simulating audio processing...', 'info');
                this.log('‚Üí Sending audio to STT service', 'info');
                this.log('‚Üí Processing with LLM', 'info');
                this.log('‚Üí Generating TTS response', 'info');
                this.log('‚Üí Playing response audio', 'info');
                this.log('Audio processing simulation complete', 'success');
            }
        }
        
        // Global instance
        const client = new ESP32TestClient();
        
        // Global functions for button handlers
        function connectDevice() { client.connectDevice(); }
        function disconnectDevice() { client.disconnectDevice(); }
        function updateConfig() { client.updateConfig(); }
        function testHealth() { client.testHealth(); }
        function toggleMicrophone() { client.toggleMicrophone(); }
        function refreshDevices() { client.refreshDevices(); }
        function clearLog() { 
            document.getElementById('log').textContent = 'Log cleared.\n';
        }
        
        // Volume control
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            client.log(`Volume set to ${e.target.value}%`);
        });
        
        // Auto-populate system prompt if empty
        window.addEventListener('load', () => {
            const promptField = document.getElementById('systemPrompt');
            if (!promptField.value.trim()) {
                promptField.value = "You are a helpful AI assistant for testing purposes. Respond briefly and clearly to user queries. Your responses will be converted to audio so speak naturally.";
            }
        });
    </script>
</body>
</html>
